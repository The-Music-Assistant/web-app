<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: AlphaTab/ConvertToTex.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: AlphaTab/ConvertToTex.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @class
 * @classdesc Encapsulates functions to transform internal AlphaTexStructure back into AlphaTex
 */
class ConvertToTex {
    /**
     * Converts provided AlphaTexStructure into AlphaTex
     * @param {AlphaTexStructure} alphaTexStructure The AlphaTexStructure to be converted
     * @param {object} lyrics Lyrics per track. Expected mapping track index number to lyric string
     * @returns {string} The generated AlphaTex
     */
    visitAlphaTexStructure(alphaTexStructure, lyrics) {
        let tex = "";
        alphaTexStructure.attributesStr.forEach((value, key, map) => {
            tex += "\\" + key + " " + value + "\n";
        });

        alphaTexStructure.attributesInt.forEach((value, key, map) => {
            tex += "\\" + key + " " + value + "\n";
        });

        tex += ".\n";

        let lyricIndex = 0;
        alphaTexStructure.tracks.forEach((track) => {
            tex += this.visitTrack(track, lyrics[lyricIndex]);
            lyricIndex++;
        });

        return tex;
    }

    /**
     * Converts the provided Track to AlphaTex
     * @param {Track} track The Track to be converted
     * @param {object} lyrics Lyrics per track. Expected mapping track index number to lyric string
     * @returns {string} The generated AlphaTex
     */
    visitTrack(track, lyrics) {
        let tex = "\\track " + track.getTrackName() + "\n";
        tex += this.visitTrackData(track.trackData, lyrics);
        return tex;
    }

    /**
     * Converts the provided TrackData to AlphaTex
     * @param {TrackMetaData} trackData The TrackMetaData to be converted
     * @param {object} lyrics Lyrics per track. Expected mapping track index number to lyric string
     * @returns {string} The generated AlphaTex
     */
    visitTrackData(trackData, lyrics) {
        let tex = "";
        trackData.staffs.forEach((staff) => {
            tex += this.visitStaff(staff);
        });

        return tex;
    }

    /**
     * Converts the provided Staff to AlphaTex
     * @param {Staff} staff The Staff to be converted
     * @param {object} lyrics Lyrics per track. Expected mapping track index number to lyric string
     * @returns {string} The generated AlphaTex
     */
    visitStaff(staff, lyrics) {
        let tex = "\\staff ";
        tex += "{" + staff.staffOption + "}";
        tex += this.attributesStrTex(staff.attributesStr) + "\n";
        if (lyrics) {
            tex += "\\lyrics " + lyrics + "\n"; 
        }
        staff.measures.forEach((measure) => {
            tex += this.visitMeasure(measure);
        });

        return tex;
    }

    /**
     * Converts the provided attributes String mapping to AlphaTex
     * @param {Map} attributesStr The attribute String mapping to convert. Map String attributes to String values
     * @returns {string} The generated AlphaTex
     */
    attributesStrTex(attributesStr) {
        let tex = "";
        attributesStr.forEach((value, key, map) => {
            if (tex.length > 0) {
                tex += " ";
            }
            if (key === "keySignature") {
                tex += "\\ks " + value;
            } else {
                tex += "\\" + key + " " + value;
            }
        });
        return tex;
    }

    /**
     * Converts the provided Measure to AlphaTex
     * @param {Measure} measure The Measure to be converted
     * @returns {string} The generated AlphaTex
     */
    visitMeasure(measure) {
        let tex = "";
        tex += this.attributesStrTex(measure.attributesStr);

        let ts = [-1, -1];
        measure.attributesInt.forEach((value, key, map) => {
            if (key == "tsTop") {
                ts[0] = value;
                if (ts[1] != -1) {
                    tex += " \\ts " + ts[0] + " " + ts[1];
                    ts[0] = -1;
                    ts[1] = -1;
                }
            } else if (key == "tsBottom") {
                ts[1] = value;
                if (ts[0] != -1) {
                    tex += " \\ts " + ts[0] + " " + ts[1];
                    ts[0] = -1;
                    ts[1] = -1;
                }
            } else {
                tex += " \\" + key + " " + value;
            }
        });

        measure.chords.forEach((chord) => {
            if (tex.length > 0) {
                tex += " ";
            }
            tex += this.visitChord(chord);
        });

        tex += " |\n";

        return tex;
    }

    /**
     * Converts the provided Map to a space separated list of key and value pairs
     * @param {Map} effects Map to be converted
     * @returns {string} The space separated list of key and value pairs
     */
    getEffectText(effects) {
        let effectText = "";
        effects.forEach((value, key, map) => {
            if (effectText.length > 0) {
                effectText += " ";
            }
            if (value === true) {
                effectText += key;
            } else {
                effectText += key + " " + value;
            }
        });
        return effectText;
    }

    /**
     * Converts the provided Chord to AlphaTex
     * @param {Chord} chord The Chord to be converted
     * @returns {string} The generated AlphaTex
     */
    visitChord(chord) {
        let tex = "";
        if (chord.notes.length == 1) {
            tex += this.visitNote(chord.notes[0], false);
        } else {
            tex += "(";
            let duration = -1;
            let effects = new Map();
            let noteText = "";
            chord.notes.forEach((note) => {
                let noteObj = this.visitNote(note, true);
                duration = noteObj.duration;
                noteObj.effects.after.forEach((value, key, map) => {
                    effects.set(key, value);
                });
                if (noteText.length > 0) {
                    noteText += " ";
                }
                noteText += noteObj.tex;
                let effectTextBefore = this.getEffectText(noteObj.effects.before);
                if (effectTextBefore.length > 0) {
                    noteText += "{" + effectTextBefore + "}";
                }
            });
            tex += noteText + ")";
            if (duration !== -1) {
                tex += "." + duration;
            }
            
            let effectText = this.getEffectText(effects);
            if (effectText.length > 0) {
                tex += "{" + effectText + "}";
            }
        }
        return tex;
    }

    /**
     * Converts the provided effect back to its AlphaTex version
     * @param {string} effect The effect String to be converted (expects one of: tied, dotted, crescendo, decrescendo)
     * @returns {string} The AlphaTex version of the effect
     */
    effectToSymbol(effect) {
        if (effect === "tied") {
            return "-";
        } else if (effect === "dotted") {
            return "d";
        } else if (effect === "crescendo") {
            return "cre";
        } else if (effect === "decrescendo") {
            return "dec";
        } else {
            console.log("ERROR- what:", effect);
            return effect;
        }
    }

    /**
     * @typedef {Object} NotePackage
     * @property {string} tex The generated AlphaTex
     * @property {number} duration The duration of the note
     * @property {object} effects
     * @property {Map} effects.effectsBefore The effects needed to be placed before the "." for the note
     * @property {Map} effects.effectsAfter The effects needed to be placed after the duration for the note
     */

    /**
     * Converts the provided Note to AlphaTex
     * @param {Note} note The Note to be translated
     * @param {boolean} splitInfo Boolean set to true if the translated information should be returned as an object (split into pieces)
     * @returns {(NotePackage|string)} If splitInfo is true, returns a NotePackage. Else, returns the generated AlphaTex
     */
    visitNote(note, splitInfo) {
        let tex = note.note;
        if (note.octave > 0) {
            tex += note.octave;
        }

        let effectsBefore = new Map();
        let effectsAfter = new Map();
        if (note.beatEffects) {
            note.beatEffects.forEach((value1, value2, set) => {
                let rel = value1.split(" ");
                if (Array.isArray(rel)) {
                    if (rel[0] === "tuplet") {
                        effectsAfter.set("tu", rel[1]);
                    } else if (rel[0] === "dynamic") {
                        effectsAfter.set("dy", rel[1]);
                    } else {
                        let symbol = this.effectToSymbol(rel[0]);
                        if (note.octave > 0) {
                            if (symbol === "-" || symbol === "d") {
                                effectsBefore.set(symbol, true);
                            } else {
                                effectsAfter.set(symbol, true);
                            }
                        } else {
                            effectsAfter.set(symbol, true);
                        }
                    }
                } else {
                    let symbol = this.effectToSymbol(rel);
                    if (note.octave > 0) {
                        if (symbol === "-" || symbol === "d") {
                            effectsBefore.set(symbol, true);
                        } else {
                            effectsAfter.set(symbol, true);
                        }
                    } else {
                        effectsAfter.set(symbol, true);
                    }
                }
            });
        }

        if (splitInfo) {
            let retObj = {
                tex,
                duration: note.duration,
                effects: {
                    before: effectsBefore,
                    after: effectsAfter
                }
            }
            return retObj;
        } else {
            let effectTextBefore = this.getEffectText(effectsBefore);
            if (effectTextBefore.length > 0) {
                tex += "{" + effectTextBefore + "}";
            }
            tex += "." + note.duration;
            let effectTextAfter = this.getEffectText(effectsAfter);
            if (effectTextAfter.length > 0) {
                tex += "{" + effectTextAfter + "}";
            }
            return tex;
        }
    }
}

module.exports = ConvertToTex;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AlphaTexStructure.html">AlphaTexStructure</a></li><li><a href="Chord.html">Chord</a></li><li><a href="ConvertToTex.html">ConvertToTex</a></li><li><a href="Measure.html">Measure</a></li><li><a href="Note.html">Note</a></li><li><a href="ParsedOutputManipulator.html">ParsedOutputManipulator</a></li><li><a href="ParserMeasures.html">ParserMeasures</a></li><li><a href="ParserOutput.html">ParserOutput</a></li><li><a href="PerformanceAnalyser.html">PerformanceAnalyser</a></li><li><a href="Staff.html">Staff</a></li><li><a href="Track.html">Track</a></li><li><a href="TrackMetaData.html">TrackMetaData</a></li><li><a href="Visitor.html">Visitor</a></li></ul><h3>Global</h3><ul><li><a href="global.html#checkAuth">checkAuth</a></li><li><a href="global.html">choir/get</a></li><li><a href="global.html">choir/get/members</a></li><li><a href="global.html">choir/post</a></li><li><a href="global.html#clean">clean</a></li><li><a href="global.html#cleanAndAnalyzePerformance">cleanAndAnalyzePerformance</a></li><li><a href="global.html#createEmptyProgressData">createEmptyProgressData</a></li><li><a href="global.html#devGetUser">devGetUser</a></li><li><a href="global.html#differenceChecker">differenceChecker</a></li><li><a href="global.html">exercise/get</a></li><li><a href="global.html#getAccessCode">getAccessCode</a></li><li><a href="global.html#getClefs">getClefs</a></li><li><a href="global.html#getClient">getClient</a></li><li><a href="global.html#getExpectedPerformance">getExpectedPerformance</a></li><li><a href="global.html#getLowerAndUpper">getLowerAndUpper</a></li><li><a href="global.html#getNoteStream">getNoteStream</a></li><li><a href="global.html#getPartNames">getPartNames</a></li><li><a href="global.html#join">join</a></li><li><a href="global.html">member/delete</a></li><li><a href="global.html">member/get/all</a></li><li><a href="global.html">member/get/gets-feedback</a></li><li><a href="global.html">member/get/pending</a></li><li><a href="global.html">member/post</a></li><li><a href="global.html">member/post/new/analysis</a></li><li><a href="global.html">member/post/new/no-analysis</a></li><li><a href="global.html">member/put/accept</a></li><li><a href="global.html">member/put/analysis</a></li><li><a href="global.html">member/put/no-analysis</a></li><li><a href="global.html">member/put/reject</a></li><li><a href="global.html">member/put/update</a></li><li><a href="global.html">performance-progress/get</a></li><li><a href="global.html">person/get</a></li><li><a href="global.html">person/post</a></li><li><a href="global.html">person/put</a></li><li><a href="global.html#processAlphaTab">processAlphaTab</a></li><li><a href="global.html#query">query</a></li><li><a href="global.html#replaceClientOnDisconnect">replaceClientOnDisconnect</a></li><li><a href="global.html">sheet-music-part/get</a></li><li><a href="global.html">sheet-music-part/post</a></li><li><a href="global.html">sheet-music/get</a></li><li><a href="global.html">sheet-music/get/part</a></li><li><a href="global.html">sheet-music/get/specific</a></li><li><a href="global.html">sheet-music/post</a></li><li><a href="global.html#updateExerciseTable">updateExerciseTable</a></li><li><a href="global.html#verifyAdmin">verifyAdmin</a></li><li><a href="global.html#verifyAdminOfMember">verifyAdminOfMember</a></li><li><a href="global.html#verifyMemberOfSheetMusic">verifyMemberOfSheetMusic</a></li><li><a href="global.html#verifyUserIsMember">verifyUserIsMember</a></li><li><a href="global.html#verifyUserIsVerified">verifyUserIsVerified</a></li><li><a href="global.html">visualize/get</a></li><li><a href="global.html">visualize/get/join</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a> on Thu Apr 16 2020 17:30:03 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>

import player from "./default.sf2";
import PitchDetection from "./PitchDetection";
import p5 from "p5";
import Drawer from "./Drawer";
import NoteList from "./NoteList";
import p5Sketch from "./sketch";
import {
    getSpecificSheetMusic,
    getPartSheetMusic,
    getExercise,
    userGetsFeedback,
    getSinglePartSheetMusic
} from "../../../App/musicAssistantApi";
import TexLoaded from "./TexLoaded";
import * as logs from "../../../vendors/Firebase/logs";
import { store } from "../../../store/reduxSetup";
import * as highlightingOptions from "./highlightingOptions";
import * as musicPlayerStates from "./musicPlayerStates";

// TODO: Small comment for each variable
let api; // AlphaTab API
let p5Obj; // Instance of p5 (drawing tool)
let noteStream; // Stream of midi/durations for the expected performance for the green/yellow/red highlighting
let noteStreamIndex; // Index into the note stream
let cumulativeTime; // Cumulative time passed in song used with the note stream array
let texLoaded; // Information about the alphaTex that is currently loaded
let isFirstRender; // Boolean to distinguish between the first render and subsequent renders
let barCount; // Number of bars to display at one time
let shouldResetDrawPositions; // Boolean signaling to p5Obj to reset its draw position after a page turn
let drawer; // Instance of the p5 drawer which provides information about the last note heard for drawing
let noteList; // Instance of note list providing an average measurement of the last midi value heard
let highlightMeasures; // Enum signaling to sketch when it should highlight instead of normally draw feedback (TODO: This can be removed if we have two different p5 objects)
let playerState; // Enum holding the current state of the player to avoid confusion during re-renders
let getsFeedback; // Boolean indicating whether or not the user gets feedback
let sheetMusicLength; // Number holding the length of the current sheet music (used for re-rendering in the performance overview page vs the exercise or sheet music view)

/**
 * Initializes the AlphaTab API
 * Displays the piece of music on the screen
 */
export const initializeAPI = () => {
    setInitialVariableValues();

    // AlphaTab API settings
    let settings = {
        player: {
            enablePlayer: true,
            enableCursor: true,
            soundFont: player,
            scrollElement: "#wrapper"
        },
        display: {
            layoutMode: "horizontal",
            startBar: 1,
            barCount
        }
    };

    // Creates the AlphaTab API
    api = new window.alphaTab.platform.javaScript.AlphaTabApi(
        document.querySelector("#alpha-tab-container"),
        settings
    );

    // Listener executed when AlphaTab is rendered on the screen
    api.addPostRenderFinished(alphaTabPostRenderFinished);

    // Listener executed when the player state changes (e.g. play, pause, and stop)
    api.addPlayerStateChanged(alphaTabPlayerStateChanged);

    // Listener executed when the player finishes playing the song
    api.addPlayerFinished(alphaTabPlayerFinished);
};

/**
 * Sets global file variables to their initial values
 */
const setInitialVariableValues = () => {
    api = null;
    p5Obj = null;
    noteStream = [-1, 0];
    noteStreamIndex = 0;
    cumulativeTime = 0;
    texLoaded = null;
    isFirstRender = false;
    barCount = 20;
    shouldResetDrawPositions = true;
    drawer = null;
    noteList = null;
    highlightMeasures = highlightingOptions.HIGHLIGHT_OFF;
    playerState = 0;
    getsFeedback = false;
    sheetMusicLength = null;
};

/**
 * Run when AlphaTab is rendered on the screen
 */
const alphaTabPostRenderFinished = () => {
    // Checks if the user gets feedback (used for user testing)
    checkIfUserGetsFeedback();

    // Retrieves staff lines using IDs attacked to elements generated by AlphaTab
    // Note: This required editing AlphaTab.js directly
    let topLine = document.getElementById("rect_0");
    let nextLine = document.getElementById("rect_1");

    x1(topLine, nextLine);
    x2(topLine, nextLine);
};

/**
 * Handles changes to AlphaTab's player state
 * TODO: What does a "real stop" mean?
 */
const alphaTabPlayerStateChanged = () => {
    // Due to our page turns, the AlphaTex is re rendered and the player state is automatically "stopped" as part of the re rendering
    // We want the sheet music to keep playing though so the checks are as follows
    // TODO: What does this comment mean ^^
    if (
        api.playerState !== musicPlayerStates.PLAYING &&
        playerState === musicPlayerStates.PLAYING
    ) {
        // Real stop -> stop playing the music
        stopPlayingMusic();
        resetSheetMusic();
    } else if (
        api.playerState === musicPlayerStates.PLAYING &&
        playerState === musicPlayerStates.STOPPED
    ) {
        // Real play -> play the music
        startPlayingMusic();
    } else if (playerState === musicPlayerStates.PAGE_CHANGED) {
        // Request was made to destroy the api -> so stop playing the music
        stopPlayingMusic();
    }
};

/**
 * Starts playing the sheet music and getting pitches from the microphone
 * TODO: Who tells AlphaTab to start playing?
 */
const startPlayingMusic = () => {
    shouldResetDrawPositions = true; // signals to p5Obj to draw from the beginning
    playerState = musicPlayerStates.PLAYING; // Note in our runner that our current state is playing

    // Since AlphaTab might have re rendered, try and update the top line and distance between lines in the drawer
    try {
        // TODO: Do we need to grab these values every time or can we store them?
        let topLine = document.getElementById("rect_0");
        let nextLine = document.getElementById("rect_1");
        const topLineHeight = topLine.y.animVal.value;

        const distanceBetweenLines = nextLine.y.animVal.value - topLineHeight;
        drawer.setTopLineAndDistanceBetween(
            topLineHeight + 1,
            distanceBetweenLines,
            texLoaded.getStartOctave()
        );
    } catch (error) {
        logs.sheetMusicError(null, error, "[alphaTabControls/alphaTabPlayerStateChanged]");
    }

    // TODO: Prevent playback range also during playing
    api.playbackRange = null; // Stops the default behavior of AlphaTab playing on the selected playback range if present
    api.timePosition = 0; // Start playing at the beginning of the piece

    // Runs the pitch detection model on microphone input and displays it on the screen
    // TODO: Don't show player controls (e.g. play and pause buttons) until AlphaTab and ML5 are ready
    PitchDetection.startPitchDetection();
};

/**
 * Stops playing the music
 * Shuts off pitch detection (this does not turn the microphone off)
 * Resets the sheet music (this is due to pagination)
 */
const stopPlayingMusic = () => {
    // Stops the pitch detection
    PitchDetection.stopPitchDetection(store.getState().practice.selectedSheetMusicId);

    // Changes player state to stopped
    playerState = musicPlayerStates.STOPPED;

    // Resets the sheet music back to the beginning
    resetSheetMusic();
};

/**
 * Clears the p5 drawing for real-time feedback
 * Resets the sheet music back to the beginning
 */
const resetSheetMusic = () => {
    // Clears the p5 drawing
    p5Obj.clear();

    // Resets the sheet music
    api.settings.display.startBar = 1;
    api.settings.display.barCount = barCount;
    api.updateSettings();
    api.render();

    // Resets the progress through expected performance
    noteStreamIndex = 0;
    cumulativeTime = 0;
};

/**
 * Checks if the user gets feedback
 * This is used for user testing
 */
const checkIfUserGetsFeedback = () => {
    if (playerState !== musicPlayerStates.PLAYING) {
        // Only checks for feedback flag when the play button is clicked
        userGetsFeedback({ sheetMusicId: store.getState().practice.selectedSheetMusicId })
            .then(response => {
                getsFeedback = response.data.gets_feedback;
            })
            .catch(error => {
                logs.sheetMusicError(null, error, "[alphaTabControls/alphaTabRenderFinished]");
            });
    }
};

/**
 * TODO: Come up with a better function name and split code
 */
const x1 = (topLine, nextLine) => {
    // During page turns, we only need to update a set of variables so do the part in the if statement
    if (isFirstRender) {
        // Retrieves the height of the staff lines based on a relative offset to their wrapping container
        // This is used to set up the p5Obj canvas so the canvas needs to be directly on top of the alphaTab container where these are stored
        // On a re-render, update the top line height and distance between lines which might have changed
        const topLineHeight = topLine.y.animVal.value;
        const distanceBetweenLines = nextLine.y.animVal.value - topLineHeight;
        drawer.setTopLineAndDistanceBetween(
            topLineHeight + 1,
            distanceBetweenLines,
            texLoaded.getStartOctave()
        );

        // Tex loaded wrapper tracks the position of the first measure which will now have moved and may have changed size
        // On a re-render, the bar cursor will go back to the beginning of the music, so use its position to update the first bar position
        let barCursor = document.querySelector(".at-cursor-bar");
        texLoaded.firstBarMeasurePosition = {
            left: parseInt(barCursor.style.left.substring(0, barCursor.style.left.length - 2), 10),
            top: parseInt(barCursor.style.top.substring(0, barCursor.style.left.length - 2), 10),
            width: parseInt(
                barCursor.style.width.substring(0, barCursor.style.left.length - 2),
                10
            ),
            height: parseInt(
                barCursor.style.height.substring(0, barCursor.style.left.length - 2),
                10
            )
        };

        // On a re render, the alpha tab surface might have changed size, so resize the p5 drawing canvas to overlay it
        let aTS = document.getElementById("aTS");
        p5Obj.resizeCanvas(aTS.clientWidth, aTS.clientHeight);

        // On a re-render, we may have gone to the performance overview which changes the behavior of the p5Obj to start highlighting
        if (highlightMeasures === highlightingOptions.HIGHLIGHT_PENDING_START) {
            startHighlighting();
        } else if (highlightMeasures === highlightingOptions.HIGHLIGHT_PENDING_STOP) {
            // Otherwise, we are either in the exercise view or the sheet music view and need to stop highlighting reverting to normal drawing behavior
            stopHighlighting();
        }
        return;
    } else {
        // On the first render, isFirstRender will be false and this will signal an initial setup of the variables
        isFirstRender = true;
        highlightMeasures = highlightingOptions.HIGHLIGHT_OFF; // On the first render, we are on the sheet music view so signal that highlighting is off
    }
};

/**
 * TODO: Come up with a better function name and split code
 */
const x2 = (topLine, nextLine) => {
    // We were getting an error where rect_0 or rect_1 were null even though AlphaTab said they were rendered
    // This sets up an interval to keep waiting for them to not be null before moving on with the render process
    const lineReadyID = setInterval(() => {
        if (topLine !== null && nextLine !== null) {
            // stop interval from running
            clearInterval(lineReadyID);

            // Retrieves the height of the staff lines based on a relative offset to their wrapping contanier
            // Used to setup the p5Obj canvas so the canvas needs to be directly on top of the alphaTab container where these are stored
            const topLineHeight = topLine.y.animVal.value;
            const distanceBetweenLines = nextLine.y.animVal.value - topLineHeight;

            // Tex loaded wrapper tracks the position of the first measure which will now have moved and may have changed size
            // On the intial render, the bar cursor will be at the beginning of the music so use its position to set up the first bar position
            let barCursor = document.getElementsByClassName("at-cursor-bar")[0];
            texLoaded.firstBarMeasurePosition = {
                left: parseInt(
                    barCursor.style.left.substring(0, barCursor.style.left.length - 2),
                    10
                ),
                top: parseInt(
                    barCursor.style.top.substring(0, barCursor.style.left.length - 2),
                    10
                ),
                width: parseInt(
                    barCursor.style.width.substring(0, barCursor.style.left.length - 2),
                    10
                ),
                height: parseInt(
                    barCursor.style.height.substring(0, barCursor.style.left.length - 2),
                    10
                )
            };

            // Creates a new drawer using the top line height, distance between lines, and start octave of the music to decide
            // how high to draw the notes for feedback
            drawer = new Drawer(
                topLineHeight + 1,
                distanceBetweenLines,
                texLoaded.getStartOctave()
            );

            // Creates a new p5 instance which we will use for highlighting during performance overview and for real time feedback during performance
            p5Obj = new p5(p5Sketch);
            // setup is called immediately upon creating a new p5 sketch but we need to call it explictly to give it a handle
            // to the drawer that we created. This also signals to actually create an appropriately sized canvas since Alpha Tab
            // is now actually rendered to the dom
            p5Obj.setup(drawer);

            // Prepares for microphone input sets up the pitch detection model
            PitchDetection.setupPitchDetection().catch(error => {
                logs.sheetMusicError(null, error, "[alphaTabControls/alphaTabRenderFinished]");
            });
        } else {
            // keeps trying to retrieve the top line and next line of the Alpha Tab music until they are loaded in the dom
            topLine = document.getElementById("rect_0");
            nextLine = document.getElementById("rect_1");
        }
    }, 500);
};

/**
 * Destroys the api if initialized
 * Destroys the p5Obj if initialized
 * Stops the microphone input it is being used
 */
export const destroy = () => {
    if (playerState === musicPlayerStates.PLAYING) {
        // Stops the player
        playerState = musicPlayerStates.PAGE_CHANGED;
        api.stop();
    }

    // Returns a promise that waits for AlphaTab to stop playing
    return new Promise(resolve => {
        // Waits for the player state to change before destroying the api
        const intervalId = setInterval(() => {
            if (playerState === 0) {
                // Stops the interval
                clearInterval(intervalId);

                if (PitchDetection.micStream && PitchDetection.micStream !== null) {
                    // Ends pitch detection
                    PitchDetection.endPitchDetection();
                }
                if (api !== null) {
                    // Destroys the AlphaTab api
                    api.destroy();
                }
                if (p5Obj !== null) {
                    // Removes the p5 canvas
                    p5Obj.remove();
                }

                // Resets the global file variable values
                setInitialVariableValues();

                // Resolves the promise
                resolve();
            }
        }, 500);
    });
};

/**
 * Resets the time back to the beginning of the song and our tracker points at the beginning of the piece again
 */
const alphaTabPlayerFinished = () => {
    noteStreamIndex = 0;
    cumulativeTime = 0;
};

/**
 * Change which track Alpha Tab is rendering based on the provided part name
 * @param {string} partName - The part name to change to. Part names are expected to be "tx" where x is the track number
 */
export const changePart = partName => {
    let trackNumber = parseInt(partName.substring(1), 10);
    // If we have the track number that is being asked then switch to that track
    if (!texLoaded.currentTrackIndexes.includes(trackNumber)) {
        texLoaded.updateCurrentTrackIndexes(trackNumber);

        api.renderTracks([api.score.tracks[texLoaded.currentTrackIndexes[0]]]);

        // sends out request for the expected performance of the currently rendered track
        // assumes user wants to sing the selected part and will draw the green/yellow/red line appropriately
        // TODO: Discuss with client and users, is this correct behavior? Do they want to always see red/yellow/green for their part only
        let data = {
            sheetMusicId: store.getState().practice.selectedSheetMusicId,
            partName: texLoaded.partNames[trackNumber]
        };
        getPartSheetMusic(data)
            .then(response => {
                noteStream = response.data.performance_expectation;
                noteList.updateBounds(response.data.lower_upper[0], response.data.lower_upper[1]);
                texLoaded.typeOfTex = "Sheet Music";
            })
            .catch(error => {
                logs.sheetMusicError(
                    error.response.status,
                    error.response.data,
                    "[alphaTabControls/changePart]"
                );
            });
    }
};

/**
 * Highlights the sheet music based on performance (green, yellow, or red)
 */
const startHighlighting = () => {
    highlightMeasures = highlightingOptions.HIGHLIGHT_ON;
    p5Obj.loop();
};

/**
 * Removes highlighting on the sheet music
 */
const stopHighlighting = () => {
    highlightMeasures = highlightingOptions.HIGHLIGHT_OFF;
    p5Obj.noLoop();
    p5Obj.clear();
};

/**
 * Switch between different views deciding what for AlphaTab to show and triggers updates
 * @param {String} value - The value of the selected drop down in drop down list with id texToDisplay
 * @param {number} measureStart - The start measure number, only needed during exercise generation to specify which measure to start rendering
 * @param {*} measureEnd - The end measure number, only needed during exercise generation to specify which measure to stop rendering inclusive
 */
export const changeMusic = async (value, measureStart, measureEnd) => {
    if (texLoaded !== null && value === texLoaded.typeOfTex) {
        return;
    } else {
        // sheetMusic is the default view and includes a paged view with normal feedback behavior from the p5Obj
        if (value === "sheetMusic") {
            highlightMeasures = highlightingOptions.HIGHLIGHT_PENDING_STOP;
            api.settings.display.barCount = barCount;
            api.updateSettings();
            await loadTex();
        } else if (value === "myPart") {
            // myPart is a special version of sheetMusic which indicates that the user wants to hear and see only their part in this sheet music
            // Therefore, we want the normal feedback behavior from the p5Obj and the normal paged view
            highlightMeasures = highlightingOptions.HIGHLIGHT_PENDING_STOP;
            api.settings.display.barCount = barCount;
            api.updateSettings();
            await loadJustMyPart();
        } else if (value === "performance") {
            // performance is an overview of all the sheet music and changes the p5Obj behavior to highlight all of the measures
            // based on current performance analysis.
            // This requires re rendering alpha tab to display the full measures of the sheet music, no paged view
            highlightMeasures = highlightingOptions.HIGHLIGHT_PENDING_START;
            api.settings.display.barCount = sheetMusicLength !== null ? sheetMusicLength : barCount;
            api.updateSettings();
            await loadTex();
        } else if (value === "exercise" && measureStart && measureEnd) {
            // exercise signals that the user wanted to generate an exercise and they must specify what the start and end measure is
            // it is assumed that the measureStart and measureEnd have already been checked to be within the bounds of the music
            // Need paged view and normal p5Obj real time feedback behavior
            highlightMeasures = highlightingOptions.HIGHLIGHT_PENDING_STOP;
            api.settings.display.barCount = barCount;
            api.updateSettings();
            await loadExercise(measureStart, measureEnd);
        } else {
            // This shouldn't run which is why the log signals that the provided value is unknown
            // The else can be expanded for new options in the drop down
            console.log("not recognized: ", value);
        }
    }
};

/**
 * Converts a time position in seconds to what measure that it occurs in
 * @param {number} currentPosition - The current time position that we are on
 * @param {number} currentMeasure - The current measure number that we are on
 * @param {number[]} measureToLength - Array holding the length of each measure in seconds
 */
export const timeToMeasureNumber = (currentPosition, currentMeasure, measureToLength) => {
    // specify how close that we need to get to the target position before we are confident that we are in the correct measure
    const EPSILON = 0.01;
    let tempCurrentPosition = currentPosition;
    let tempCurrentMeasure = currentMeasure;
    while (tempCurrentPosition > EPSILON) {
        tempCurrentPosition -= measureToLength[tempCurrentMeasure - 1];
        tempCurrentMeasure++;
    }
    return tempCurrentMeasure;
};

/**
 * Converts the playback range if defined in AlphaTab to the measure numbers that start and end that range
 * @returns Either an array with the start and end measure numbers or null if there is no playback range
 */
export const getPlaybackRange = () => {
    const measureToLength = texLoaded.measureLengths;
    let playbackMeasures = null;
    if (measureToLength !== null) {
        if (api.playbackRange !== null) {
            playbackMeasures = [];
            let currentPosition = api.timePosition / 1000; // timeposition is tied to the bar cursor position in milliseconds so divide by 1000 to get seconds
            let comparePosition = currentPosition;
            // The time position is used to set up a ratio to figure out where the end measure should be
            // A special case occurs when the time position is at 0 seconds since the ratio will cause a divide by 0 error
            // To attempt to fix this, we try and set the api time position to the end of the first measure to get a good ratio
            // TODO: Fix this for the 1st measure, this solution isn't working
            if (currentPosition === 0) {
                api.timePosition = measureToLength[0];
                comparePosition = api.tickPosition;
            }
            let ratio = api.tickPosition / comparePosition;
            // calculates the end time of the range based on ratio of the start position
            let targetEndTime =
                api.playbackRange.endTick / ratio - api.playbackRange.startTick / ratio;
            let currentMeasure = 1;
            currentMeasure = timeToMeasureNumber(currentPosition, currentMeasure, measureToLength);
            // saves the start measure number of the playback range
            playbackMeasures.push(currentMeasure);

            currentPosition = targetEndTime;
            currentMeasure = timeToMeasureNumber(currentPosition, currentMeasure, measureToLength);
            // saves the end measure number of the playback range
            playbackMeasures.push(currentMeasure - 1);
        }
    }
    return playbackMeasures;
};

// /**
//  * Sets the target track to either be muted or not. If checked then the target track will not be muted
//  * @param {Boolean} isChecked - If true then we want to hear this track, otherwise mute this track
//  * @param {String} name - Name of the track to be heard or muted
//  */
// const changeTrackVolume = (isChecked, name) => {
//     if (texLoaded) {
//         let partIndex = texLoaded.partNames.indexOf(name);
//         if (partIndex > -1) {
//             texLoaded.mutedTracks[partIndex] = !isChecked;
//             let muteTrackList = [];
//             let playTrackList = [];
//             for (let i = 0; i < texLoaded.mutedTracks.length; i++) {
//                 if (texLoaded.mutedTracks[i]) {
//                     muteTrackList.push(i);
//                 } else {
//                     playTrackList.push(i);
//                 }
//             }
//             // api.changeTrackMute(muteTrackList, true);
//             // api.changeTrackMute(playTrackList, false);
//             api.changeTrackMute([partIndex], !isChecked)
//         }
//     }
// }

/**
 * Loads just the user's part for this sheet music logging it as an exercise and isolates their part for playback
 */
export const loadJustMyPart = async () => {
    // Clears the "exercise" option from the texToDisplay drop down if present since that is only generated when viewing an exercise
    let texToDisplay = document.getElementById("texToDisplay");
    texToDisplay.options[3] = null;

    try {
        const singlePartResponse = await getSinglePartSheetMusic({
            sheetMusicId: store.getState().practice.selectedSheetMusicId
        });
        // update the wrapper for the loaded tex since it has changed
        texLoaded.update(
            "Sheet Music",
            singlePartResponse.data.part_list,
            singlePartResponse.data.clefs,
            singlePartResponse.data.part,
            null,
            1,
            1
        );
        // update the current track index and re render the track
        texLoaded.updateCurrentTrackIndexes(0);
        api.tex(singlePartResponse.data.sheet_music, texLoaded.currentTrackIndexes);

        // Update the sheetMusicPart drop down list with the new list of parts
        updateDropdown(singlePartResponse.data.part_list);

        // updates the expected performance of the music and several internal variables about the loaded sheet music
        noteStream = singlePartResponse.data.performance_expectation;
        noteList.clear();
        noteList.updateBounds(
            singlePartResponse.data.lower_upper[0],
            singlePartResponse.data.lower_upper[1]
        );
        texLoaded.setMeasureLengths(singlePartResponse.data.measure_lengths, barCount);
        sheetMusicLength = texLoaded.measureLengths.length;
        texLoaded.updateLengthsPerSection(1, texLoaded.measureLengths.length + 1, barCount);
        texLoaded.typeOfTex = "Sheet Music";
    } catch (error) {
        logs.sheetMusicError(
            error.response.status,
            error.response.data,
            "[alphaTabControls/loadJustMyPart]"
        );
    }
};

/**
 * Loads an exercise based on user provided measure numbers
 */
const loadExercise = async (measureStart, measureEnd) => {
    // Adds and auto selects the "exercise" option from the texToDisplay drop down which only lasts as long as we are viewing this exercise
    let texToDisplay = document.getElementById("texToDisplay");
    texToDisplay.options[3] = new Option("Exercise", "exercise", false, true);

    // Assumes currentTrackIndexes[0], measureStart, and measureEnd are valid by this point
    // Defaults to non duration exercise
    // TODO: Get duration exercise if measure needs a lot of work, otherwise get normal exercise
    let data = {
        sheetMusicId: store.getState().practice.selectedSheetMusicId,
        trackNumber: texLoaded.currentTrackIndexes[0] + 1,
        staffNumber: 1,
        measureStart,
        measureEnd,
        isDurationExercise: false
    };

    // TODO: Save responses so that we don't have to ask for them each time. Note: You will still need to save this as an exercise count
    const exerciseResponse = await getExercise(data);
    try {
        // update wrapper about new sheet music and re render
        texLoaded.update(
            "Exercise",
            exerciseResponse.data.part_list,
            exerciseResponse.data.clefs,
            exerciseResponse.data.part,
            exerciseResponse.data.exerciseId,
            measureStart,
            measureEnd
        );
        api.tex(exerciseResponse.data.sheet_music, texLoaded.currentTrackIndexes);

        // Update the sheetMusicPart drop down list with the new list of parts
        updateDropdown(exerciseResponse.data.part_list);

        // updates the expected performance of the music and several internal variables about the loaded sheet music
        noteStream = exerciseResponse.data.performance_expectation;
        noteList.clear();
        noteList.updateBounds(
            exerciseResponse.data.lower_upper[0],
            exerciseResponse.data.lower_upper[1]
        );
        texLoaded.setMeasureLengths(exerciseResponse.data.measure_lengths, barCount);
    } catch (error) {
        logs.sheetMusicError(
            error.response.status,
            error.response.data,
            "[alphaTabControls/loadExercise]"
        );
    }
};

/**
 * TODO: This function likely will be removed when UI updates are made
 */
export const updateDropdown = partList => {
    // TODO: Once track muting is fixed, uncomment to re add it
    // let trackVolume = document.getElementById("volumeTracks");
    // const numberOfChildren = trackVolume.children.length;
    // for (let i = 0; i < numberOfChildren; i++) {
    //     trackVolume.removeChild(trackVolume.lastElementChild);
    // }
    let sheetMusicPartDropdown = document.getElementById("sheetMusicPart");
    if (sheetMusicPartDropdown) {
        let i = 0;
        for (; i < partList.length; i++) {
            sheetMusicPartDropdown.options[i] = new Option(partList[i], "t" + i, false, false);

            // const newTrackVolume = document.createElement('li');
            // const x = document.createElement("INPUT");
            // x.setAttribute("type", "checkbox");
            // x.checked = true;
            // newTrackVolume.appendChild(x);
            // newTrackVolume.appendChild(document.createTextNode(partList[i]));
            // newTrackVolume.onclick = function() {
            //     changeTrackVolume(children[0].checked, innerText);
            // };
            // trackVolume.appendChild(newTrackVolume);
        }
        let optionsLength = sheetMusicPartDropdown.options.length;
        let lastIndex = i;
        for (; i < optionsLength; i++) {
            sheetMusicPartDropdown.options[lastIndex] = null;
        }
    }
};

/**
 * Loads the overall sheet music defaulting to showing the user's part for the song
 */
const loadTex = async () => {
    // Clears the "exercise" option from the texToDisplay drop down if present since that is only generated when viewing an exercise
    let texToDisplay = document.getElementById("texToDisplay");
    texToDisplay.options[3] = null;

    let data = {
        sheetMusicId: store.getState().practice.selectedSheetMusicId
    };

    // TODO: Save this response so that we can switch back to the sheet music without having to re-request the sheet music from the database
    try {
        const sheetMusicResponse = await getSpecificSheetMusic(data);
        let partList = sheetMusicResponse.data.part_list;
        // Initializes wrapper about the sheet music if first render or updates wrapper if already present
        if (texLoaded === null) {
            texLoaded = new TexLoaded(
                "Sheet Music",
                partList,
                sheetMusicResponse.data.clefs,
                sheetMusicResponse.data.part,
                null,
                1,
                1,
                store.getState().practice.selectedSheetMusicId
            );
        } else {
            texLoaded.update(
                "Sheet Music",
                partList,
                sheetMusicResponse.data.clefs,
                sheetMusicResponse.data.part,
                null,
                1,
                1
            );
        }

        // Update the sheetMusicPart drop down list with the new list of parts
        updateDropdown(partList);

        // Isolates the user's part from the part list setting it to be the displayed track when alpha tab renders
        for (let i = 0; i < partList.length; i++) {
            if (partList[i] === texLoaded.myPart) {
                texLoaded.updateCurrentTrackIndexes(i);
                let sheetMusicPartDropdown = document.getElementById("sheetMusicPart");
                if (sheetMusicPartDropdown) {
                    sheetMusicPartDropdown[i].selected = true;
                }
                break;
            }
        }

        // renders the user's part but plays all the parts together during playback
        api.tex(sheetMusicResponse.data.sheet_music, texLoaded.currentTrackIndexes);

        data.partName = sheetMusicResponse.data.part_list[texLoaded.currentTrackIndexes[0]];

        // gets and updates expected performance data for the user's part
        const partResponse = await getPartSheetMusic(data);
        noteStream = partResponse.data.performance_expectation;
        noteList = new NoteList(0);

        // updates several internal variables about the loaded sheet music
        noteList.updateBounds(partResponse.data.lower_upper[0], partResponse.data.lower_upper[1]);
        texLoaded.setMeasureLengths(partResponse.data.measure_lengths, barCount);
        sheetMusicLength = texLoaded.measureLengths.length;
        texLoaded.updateLengthsPerSection(1, texLoaded.measureLengths.length + 1, barCount);
        texLoaded.typeOfTex = "Sheet Music";
    } catch (error) {
        logs.sheetMusicError(
            error.response.status,
            error.response.data,
            "[alphaTabControls/loadTex]"
        );
    }
};
